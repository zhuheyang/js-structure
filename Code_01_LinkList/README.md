# LinkList基本的构建

感觉如果想要做好链表, ES6中模块的输入与输出语法, 还是很需要的.  
另外就是, 创建自己的一些小项目, 也要配置好ESLint方面的代码静态检测工具, 就不用老是到运行时再报错了!

## 画图进行算法与数据结构的理解

理解这些方法, 最重要的, 还是需要辅以必要的画图解释, 自己理解是一方面, 让自己能够更直观地思考, 同时相信推算出来的结果, 这很重要

## 测试用例

其实测试用例, 简单的单元测试也就这么一回事而已.  
写完一个函数, 或者一个模块, 就要测试一下各个函数的输入以及输出是否真是这么一回事  
很多时候, 即便逻辑感觉很对, 同时代码也很顺利地写下来, 但真的去运行的话, 总会发现有那么一丁点的地方有错的  
就好比一下的代码中, 赋值运算符的等号与比较运算符中的'=='弄错的话, 结果就完全不是这么一回事了

```js
LinkedList.prototype.append = function (element) {
    // 如果下面写出了this.head = null, 那么之后的结果就完全崩了的
    if(this.head == null) {
        this.addFirst(element)
    } else {
        this.insertAfterNode(element, this.tail)
    }
}
```

### 大段的代码或者测试, 用函数包装起来

这个对象这么多的方法, 显然不能都在一个函数中将全部的测试都能进行完, 这就需要将其拆分成不同的几个测试函数  
例如test1(), test2(), 乃至test3()进行相关的输入输出验证了  
同时, 划分成不同的测试函数, 则对于某个函数中的返回值, 另外的测试函数可以加以利用, 非常方便

```js
// 就好比需要测试LinkedList.prototype.reverse方法, 需要以一个链表对象进行操作
// 如果再在test3()中新建一个链表,未免太繁琐了, 则在之前测试成功的基础上, 引用test2()中的ll2, 即可快速进行相关的方法验证
function test3() {
    var ll3 = test2()
    ll3.append('mememda')
    console.log(ll3.reverse())
}
```